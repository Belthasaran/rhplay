# Nostr Client Integration Plan

## 1. Objectives
- Provide a resilient Nostr client stack that can publish and subscribe to RHTools events (profiles, keypairs, trust declarations, ratings, future forum/chat objects).
- Support both foreground (Electron renderer) and optional background service operation so that events can be processed even when the main UI is closed.
- Maintain a consistent follow list derived from trusted admin/master/admin-user keypairs and relevant subject keys, enabling automatic discovery of authoritative updates.
- Lay groundwork for advanced features: secure messaging, forum threads, user verification, and cross-device synchronization.

## 2. Functional Requirements
- **Outgoing events**: Persist, sign, queue, and broadcast Nostr events generated by the app (existing profile/keypair/rating publications, future declarations).
- **Incoming events**: Subscribe to relays, download events matching filters (follow list, app-specific kinds), validate signatures, deduplicate, and persist raw data in the appropriate `nostr_*` databases.
- **Offline resilience**: Continue relay synchronization in the background process with exponential backoff, relay health tracking, and catch-up logic when the foreground client reconnects.
- **Follow list management**: Automatically derive the follow list from:
  - All admin master/admin keypairs with Nostr public keys.
  - Subject keys of trust declarations.
  - User profile keys that published game ratings relevant to the library (extendable).
- **Security & privacy**: Keep secret keys in secure storage; decrypt only in the process requiring signing. Provide encryption primitives for DMs (future work).
- **Configurability**: Allow users to control relays, background service enablement, bandwidth constraints, Storage TTL, and logging.

## 3. Architecture Overview

```
+---------------------------+          +---------------------------+
| Electron Renderer (UI)   |  IPC/RPC |    Nostr Runtime Service  |
| - Publish requests       | <------> |  - Relay connections      |
| - Relay status display   |          |  - Event subscription     |
| - Feed presentation      |          |  - Outgoing queue flush   |
+---------------------------+          |  - Follow list refresh    |
             ^                         |  - Background scheduler   |
             |                         +-----------+---------------+
             |                                     |
             |                             +-------v-------+
             |                             | Database Tier |
             |                             | (SQLite files)|
             |                             +---------------+
             v
+---------------------------+
|  OnlineProfileManager     |
|  NostrLocalDBManager      |
+---------------------------+
```

### 3.1 Processes
- **Main Electron process**: Spawns/manages a dedicated Node.js worker (or Electron BrowserWindow with background scripts) called the *Nostr Runtime Service* (NRS). NRS persists across renderer reloads and can optionally continue when the UI is closed.
- **Renderer**: Sends commands to NRS via IPC channels (through `preload` bridge) and receives status updates (subscriptions, feed updates, errors).
- **Optional stand-alone daemon**: For headless operation, bundle NRS as a CLI entry point (`enode.sh nostr-daemon`), reusing shared libraries.

### 3.2 Data Flow
1. Renderer requests publication → IPC to NRS → NRS signs event (via `OnlineProfileManager`/`NostrLocalDBManager`) → event stored in `nostr_cache_out` → relay send.
2. NRS subscribes to configured relays → receives events → stores raw event in `nostr_cache_in` + archives → deduplicates → signals renderer via IPC for UI updates.
3. Follow list updates (see §4) trigger a resubscription cycle with new filters.

### 3.3 Library Selection

| Library | Strengths | Limitations | Proposed Usage |
|---------|-----------|-------------|----------------|
| `nostr-tools` | Mature primitives, signing, event builders, utilities. | Low-level; manual relay handling. | **Core cryptography and basic client operations**. Already in use; keep for signing, event ID, nip-19 encoding. |
| `@nostr/gadgets` | High-level client toolkit, relay pooling, persistent subscriptions, advanced filtering, batching. | Newer; evaluate stability. | **Primary runtime** for relay management, worker orchestration, queue handling. Provides best path to support advanced features (DMs, groups). |
| `@nostr-dev-kit/ndk` | Comprehensive client framework, caching, background workers, many extensions (NIP-07/46). | Larger dependency, but battle-tested. | Integrate selectively (e.g., fallback to NDK for features Gadgets lacks). |
| `@nostrify/nostrify` | Utility functions, async iterators, minimal overhead. | Minimal feature set. | Supplementary for stream processing if needed. |
| `@nostr-connect/connect` | Relay connection manager for remote signing (NIP-46). | May be overkill now. | Reserve for remote signer integration (future high-security operations). |

**Recommendation**: Build NRS on top of `@nostr/gadgets` for relay orchestration + `nostr-tools` primitives. Keep NDK as optional plugin if we need robust connection pooling or relay scoring. Plan abstractions so either backend can be swapped.

## 4. Follow List Management
- **Source data**:
  - `admin_keypairs`, `profile_keypairs` tables for any Nostr keys (master/admin/user op).
  - `admindeclarations` subjects referencing Nostr public keys (parse `content_json`).
  - Explicit user-configured follows (future UI).
- **Processing**:
  - Periodic task (e.g., every 10 minutes or on data change) recomputes follow set.
  - Store in `nostr_follow_entries` table with metadata (type, source, last_verified).
  - NRS updates subscription filters (kinds 0, 3, 31001, 31106, etc.) accordingly.
- **Extensibility**: Provide weighting/priority for master/admin keys to ensure their events are never dropped.

## 5. Event Handling Strategy
- **Outgoing** (existing `nostr_cache_out`):
  - Implement queue worker in NRS reading pending rows, signing if necessary, pushing to relays.
  - Track per-event status (pending, sent, confirmed). Update `nostr_status` columns in relevant tables (keypairs, declarations, profiles).
- **Incoming** (`nostr_cache_in`, `nostr_store_*`, `nostr_archive_*`):
  - For each event: validate signature, store raw JSON, dedupe by event ID, index by kind, author, `d` tag.
  - Parse and route to domain-specific handlers (profiles, ratings, declarations). Update domain tables (`user_profiles`, `admindeclarations`, etc.) or queue for moderation review.
- **Retention policy**: use `keep_for` column to control TTL; archive older events to `nostr_archive_##` automatically.

## 6. Background Service Implementation
- **Process model**: Node worker launched via `child_process.fork()` from main process, with message channel for IPC, or use Electron's `BrowserWindow` running in headless mode for easier reuse of Node + DOM APIs.
- **Lifecycle**:
  - Auto-start with app (configurable). Provide controls in settings to pause/stop.
  - When Electron app closes, prompt user to keep service running; if accepted, detach to run as long-lived background process (Linux: systemd service entries optional; Windows: scheduled task). Document manual start via CLI.
- **Resource management**: ensure service respects rate limits, manages reconnections, and handles relay selection/preferences per user settings.

## 7. Security Considerations
- Use `safeStorage` + Profile Guard encryption for secret keys. NRS requests secrets through `OnlineProfileManager`, decrypts in-memory only, zeroises after signing.
- Provide sandbox for NRS (no renderer access). Validate all IPC payloads.
- Implement optional Tor/proxy support (`socks-proxy-agent`).
- For DMs/E2EE: plan to implement NIP-04/NIP-44 using libs from `nostr-tools` or `@nostr/gadgets` (supports encryption helpers).

## 8. Implementation Phases
1. **Foundations**
   - Finalize `NostrLocalDBManager` APIs (relay config, queue operations).
   - Implement NRS scaffold (process startup, IPC contract, logging, configuration storage in `csettings`).
   - Integrate `@nostr/gadgets` with relay connection pooling; read/write events from caches.
2. **Follow List & Subscription**
   - Create `nostr_follow_entries` table and sync task.
   - Build subscription filters (kinds and authors) and hook them to NRS.
3. **Incoming Event Routing**
   - Implement domain handlers (profiles, trust declarations, ratings) with validation pipeline.
   - Provide renderer notifications (e.g., new reviews available).
4. **Background Operation**
   - Add user controls, system tray indicator, CLI entry point.
   - Document how to run service headless.
5. **Advanced Features Roadmap**
   - DM encryption (NIP-04/44), forum announcements (kind 31100+), chat (kind 42), remote signer support, moderation queue UI.

## 9. Open Questions
- Relay discovery strategy—preload curated relays vs. allow user-provided list only?
- Resource constraints for always-on background service; need CPU/network throttling options.
- Multi-profile support: ensure per-profile identity separation while sharing runtime resources.
- Authenticated encryption for offline message storage—decide on key derivation approach (shared secrets vs. per-conversation keys).

## 10. Next Steps
1. Review/approve this architecture and library selection.
2. Lock down IPC contracts between renderer and NRS.
3. Define database schema additions (follow table, relay config table, incoming event indices).
4. Schedule implementation milestones aligned with UI work (see companion UI plan).

